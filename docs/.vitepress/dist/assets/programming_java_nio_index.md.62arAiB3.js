import{_ as t,I as l,c as d,o as r,j as o,J as p,a9 as c,a as i,d_ as s,d$ as n,e0 as _}from"./chunks/framework.Dp2GimK2.js";const u=JSON.parse('{"title":"NIO","description":"","frontmatter":{},"headers":[],"relativePath":"programming/java/nio/index.md","filePath":"programming/java/nio/index.md","lastUpdated":1765356475000}'),m={name:"programming/java/nio/index.md"};function g(f,e,N,x,I,v){const a=l("ArticleMetadata");return r(),d("div",null,[e[0]||(e[0]=o("h1",{id:"nio",tabindex:"-1"},[i("NIO "),o("a",{class:"header-anchor",href:"#nio","aria-label":"Permalink to “NIO”"},"​")],-1)),p(a),e[1]||(e[1]=c('<p><a href="https://www.bilibili.com/video/BV1QD5Nz9EXB?spm_id_from=333.788.player.switch&amp;vd_source=d044e5cf4ad97cd97410607c3e1eb064&amp;p=4" target="_blank" rel="noreferrer">点击查看 NIO 的源码分析</a></p><p>通过追溯<code>Selector.open()</code>方法的调用栈，可以发现 Selector 底层创建了一个<code>epoll</code>实例（Linux 平台），并且通过<code>epoll_ctl</code>注册了监听的文件描述符和事件类型。</p><p><img src="'+s+'" alt="" loading="lazy"></p><p><img src="'+n+'" alt="" loading="lazy"></p><p><code>epoll_create</code>：创建一个 epoll 实例，返回一个文件描述符。 <code>epoll_ctl</code>：向 epoll 实例注册、修改或删除监听的文件描述符和事件类型。 <code>epoll_wait</code>：等待事件的发生，并返回就绪的文件描述符列表。</p><p>epoll 实例是操作系统内核中的一个数据结构，它维护了一个监听的文件描述符集合。当我们通过<code>epoll_ctl</code>注册一个文件描述符时，实际上是将该文件描述符添加到 epoll 实例的监听集合中，并指定我们感兴趣的事件类型（如可读、可写等）。</p><p>当客户端连接到服务器某个端口时，硬件发起中断请求（让操作系统停止当前正在运行的进程），然后操作系统会将此连接的事件放入放入<code>rdlist</code>（就绪队列）中，表示该文件描述符已经就绪，可以进行读写操作。这时，程序进程会被唤醒，调用<code>epoll_wait</code>函数，发现<code>rdlist</code>中有新的事件，就会处理这些事件，如果没有事件，就会继续阻塞等待。</p><p>面试题：select、poll、epoll 有什么区别？</p><p><img src="'+_+'" alt="" loading="lazy"></p><p>我们常说 redis 是单线程的（<code>只是处理命令的逻辑是单线程的，多线程是在处理网络 I/O</code>），但是 redis 能够支持高并发连接（<strong>每秒数十万的请求</strong>），这就是因为 redis 使用了<code>epoll</code>这种高效的 I/O 多路复用技术。</p>',10))])}const O=t(m,[["render",g]]);export{u as __pageData,O as default};
