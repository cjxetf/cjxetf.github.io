import{_ as o,I as i,c as n,o as d,j as t,J as s,a9 as e,a as p,dl as c,dm as g,dn as m,dp as h,dq as b,dr as _,w as u,ds as k,dt as y,du as v,dv as f,dw as P,dx as C,dy as A,dz as x,dA as T}from"./chunks/framework.Dp2GimK2.js";const V=JSON.parse('{"title":"分布式事务","description":"","frontmatter":{},"headers":[],"relativePath":"programming/distributed/transaction/index.md","filePath":"programming/distributed/transaction/index.md","lastUpdated":1765356475000}'),S={name:"programming/distributed/transaction/index.md"};function z(B,a,E,q,F,I){const l=i("ArticleMetadata"),r=i("center");return d(),n("div",null,[a[1]||(a[1]=t("h1",{id:"分布式事务",tabindex:"-1"},[p("分布式事务 "),t("a",{class:"header-anchor",href:"#分布式事务","aria-label":"Permalink to “分布式事务”"},"​")],-1)),s(l),a[2]||(a[2]=e('<p>说起事务，大家第一反应可能是数据库事务，数据库事务是指一组操作要么全部成功，要么全部失败，是数据库管理系统（DBMS）用来保证<strong>数据一致性和完整性</strong>的重要机制。</p><p><strong>一致性</strong>指的是数据库在事务执行前后都必须处于一个合法的状态，不能出现数据不一致的情况。而<strong>完整性</strong>则是指数据库中的数据必须满足预定义的规则和约束条件。</p><p>事务有四个基本特性，通常称为<code>ACID</code>特性：</p><ul><li><strong>原子性（Atomicity）</strong>：事务中所有操作要么全部完成，要么全部不完成。</li><li><strong>一致性（Consistency）</strong>：事务执行的前后，数据库必须保持一致的状态。</li><li><strong>隔离性（Isolation）</strong>：多个事务并发执行时，一个事务的执行不应影响其他事务的执行。</li><li><strong>持久性（Durability）</strong>：一旦事务提交，其结果应该永久保存在数据库中，即使系统崩溃也不会丢失。</li></ul><p>在分布式系统中，因为涉及到多个服务，它们可能使用不同的数据库和存储系统，事务管理变得更加复杂。<strong>分布式事务</strong>需要协调多个独立的资源，以确保它们在一个<strong>全局事务中保持一致性</strong>。</p><h2 id="_1-案例" tabindex="-1">1.案例 <a class="header-anchor" href="#_1-案例" aria-label="Permalink to “1.案例”">​</a></h2><p>假设有一个电商系统，用户在下单时会调用订单服务，创建订单并写入数据库，然后订单服务调用账户服务和库存服务：</p><ul><li>账户服务负责扣减用户余额</li><li>库存服务负责扣减商品库存</li></ul><p><img src="'+c+'" alt="" loading="lazy"></p><h2 id="_1-1-演示" tabindex="-1">1.1.演示 <a class="header-anchor" href="#_1-1-演示" aria-label="Permalink to “1.1.演示”">​</a></h2><ol><li><p><a href="/attachments/transcation-demo.zip">点击下载资料</a></p></li><li><p>创建数据库：<code>seata_demo</code>，并导入<code>seata_demo.sql</code>脚本，数据库版本是<code>MySQL 5.0+</code>。</p></li><li><p>导入项目<code>seata-demo</code>到IDE中。</p></li><li><p>启动 <a href="https://nacos.io/docs/latest/quickstart/quick-start/?spm=5238cd80.6a33be36.0.0.52a31e5dv8eTH9" target="_blank" rel="noreferrer">Nacos</a>，以及所有服务</p><p><img src="'+g+'" alt="" loading="lazy"></p></li><li><p>测试下单功能，发出请求</p><div class="language-bash line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">curl</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -X</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> POST</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;http://localhost:8082/order?userId=user202103032042012&amp;commodityCode=100202003032041&amp;count=2&amp;money=200&quot;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p><img src="'+m+'" alt="" loading="lazy"></p><p>查询数据库，发现订单创建成功，余额和库存也扣减成功。</p></li><li><p>模拟异常情况，当在请求中只修改<code>count=10</code>，但总金额不变，即数量和总金额不匹配时，发出请求</p><p><img src="'+h+'" alt="" loading="lazy"></p><p>查询数据库，发现订单创建失败，余额竟然扣减成功：</p><p><img src="'+b+'" alt="" loading="lazy"></p></li></ol><h3 id="_1-2-分析" tabindex="-1">1.2.分析 <a class="header-anchor" href="#_1-2-分析" aria-label="Permalink to “1.2.分析”">​</a></h3><p>上面异常情况原因是因为库存服务抛出了异常，它的事务进行回滚，但是订单服务和账户服务的事务已经提交，导致数据不一致。</p><p><img src="'+_+'" alt="" loading="lazy"></p><h2 id="_2-简介" tabindex="-1">2.简介 <a class="header-anchor" href="#_2-简介" aria-label="Permalink to “2.简介”">​</a></h2><p>在分布式系统下，一个业务跨越多个服务或数据源时，每个服务都是一个分支事务，要保证所有分支事务最终状态一致，这样的事务就是分布式事务。</p><h3 id="_2-1-cap-定理" tabindex="-1">2.1.CAP 定理 <a class="header-anchor" href="#_2-1-cap-定理" aria-label="Permalink to “2.1.CAP 定理”">​</a></h3><p>1998 年，<code>Eric Brewer</code>提出了<strong>CAP 定理</strong>，指出在分布式系统中，不可能同时满足以下三个条件：</p><ul><li><strong>一致性（Consistency）</strong></li><li><strong>可用性（Avaliability）</strong></li><li><strong>分区容错性（Partition Tolerance）</strong></li></ul>',19)),s(r,null,{default:u(()=>[...a[0]||(a[0]=[t("img",{src:k,style:{"max-width":"50%"}},null,-1)])]),_:1}),a[3]||(a[3]=e('<h4 id="一致性-consistency" tabindex="-1">一致性（Consistency） <a class="header-anchor" href="#一致性-consistency" aria-label="Permalink to “一致性（Consistency）”">​</a></h4><p>指的是所有节点在同一时间看到的数据是一致的。也就是说，当一个节点对数据进行修改后，其他节点应该立即“看到”这个修改。</p><div class="vp-code-group"><div class="tabs"><input type="radio" name="group-157" id="tab-158" checked><label data-title="&lt;1&gt;" for="tab-158">&lt;1&gt;</label><input type="radio" name="group-157" id="tab-159"><label data-title="&lt;2&gt;" for="tab-159">&lt;2&gt;</label><input type="radio" name="group-157" id="tab-160"><label data-title="&lt;3&gt;" for="tab-160">&lt;3&gt;</label></div><div class="blocks"><div class="rendered-md"><p><img src="'+y+'" alt="" loading="lazy"></p></div><div class="rendered-md"><p><img src="'+v+'" alt="" loading="lazy"></p></div><div class="rendered-md"><p><img src="'+f+'" alt="" loading="lazy"></p></div></div></div><h4 id="可用性-availability" tabindex="-1">可用性（Availability） <a class="header-anchor" href="#可用性-availability" aria-label="Permalink to “可用性（Availability）”">​</a></h4><p>指的是系统在任何时候都能响应用户的请求，无论请求是成功还是失败。即使部分节点出现故障，系统仍然能够继续提供服务。</p><p><img src="'+P+'" alt="" loading="lazy"></p><p>上图中，<code>node03</code>出现故障，无法进行数据同步，当请求进来只能阻塞或者拒绝，不过还有<code>node01</code>和<code>node02</code>能够提供服务，因此系统仍然可以响应用户请求，保证了<strong>可用性</strong>，但是无法保证<strong>一致性</strong>。</p><h4 id="分区容错性-partition-tolerance" tabindex="-1">分区容错性（Partition Tolerance） <a class="header-anchor" href="#分区容错性-partition-tolerance" aria-label="Permalink to “分区容错性（Partition Tolerance）”">​</a></h4><p>指的是系统能够容忍网络分区的发生，即使网络中的某些节点无法通信，系统仍然能够继续运行。</p><blockquote><p>网络分区是指在分布式系统中，由于网络故障或延迟，导致系统中的某些节点与其他节点无法通信，从而形成独立的子系统。</p></blockquote><div class="vp-code-group"><div class="tabs"><input type="radio" name="group-185" id="tab-186" checked><label data-title="&lt;1&gt;" for="tab-186">&lt;1&gt;</label><input type="radio" name="group-185" id="tab-187"><label data-title="&lt;2&gt;" for="tab-187">&lt;2&gt;</label><input type="radio" name="group-185" id="tab-188"><label data-title="&lt;3&gt;" for="tab-188">&lt;3&gt;</label></div><div class="blocks"><div class="rendered-md"><p><img src="'+C+'" alt="" loading="lazy"></p></div><div class="rendered-md"><p><img src="'+A+'" alt="" loading="lazy"></p></div><div class="rendered-md"><p><img src="'+x+'" alt="" loading="lazy"></p></div></div></div><p>上图中，如果要保证<strong>分区容错性</strong>，那么可以让<code>node03</code>停止提供服务，当请求进来时，阻塞或者拒绝请求，等待网络恢复后数据同步完成再继续提供服务，但是这样就无法保证<strong>可用性</strong>。</p><p>在分布式系统中，<strong>分区容错性是必须要保证的</strong>，因为网络故障是不可避免的，因此在设计分布式系统时，通常需要在<strong>一致性</strong>和<strong>可用性</strong>之间进行取舍，根据具体的应用场景选择合适的策略，即，<strong>CP</strong>（一致性和分区容错性）或<strong>AP</strong>（可用性和分区容错性）。</p><blockquote><p>思考：Elasticsearch 集群是 AP 还是 CP？</p><p>Elasticsearch 集群通常被视为<code>CP</code>系统（一致性和分区容错性）。因为它优先保证数据一致性，并在网络分区时，会剔除掉无法通信的节点，通过副本分片重新分配来确保一致性，这可能导致短暂的不可用性，但最终数据是一致的。</p></blockquote><h3 id="_2-2-base-理论" tabindex="-1">2.2.BASE 理论 <a class="header-anchor" href="#_2-2-base-理论" aria-label="Permalink to “2.2.BASE 理论”">​</a></h3><p><strong>BASE 理论</strong>是对 CAP 定理的一种解决思路，包括三个思想：</p><ul><li><strong>基本可用（Basically Available）</strong>：分布式系统在出现故障时，<strong>允许损失部分可用性</strong>，即保证核心可用。</li><li><strong>软状态（Soft State）</strong>：在一定时间内，允许出现中间状态，比如临时的数据不一致。</li><li><strong>最终一致性（Eventual Consistency）</strong>：虽然无法保证强一致性，但是在软状态结束后，<strong>最终会达到数据一致</strong>。</li></ul><h3 id="_2-3-解决方案" tabindex="-1">2.3.解决方案 <a class="header-anchor" href="#_2-3-解决方案" aria-label="Permalink to “2.3.解决方案”">​</a></h3><p>分布式事务最大的问题就是各个子事务的一致性问题，因此可以借鉴 CAP 定理和 BASE 理论的思想，来设计分布式事务解决方案，比如：</p><ul><li><p><strong>AP 方案</strong>：各个子事务分别执行和提交，允许出现结果不一致，然后采用<strong>补偿机制</strong>来修正不一致的数据，实现<strong>最终一致性</strong>。</p><blockquote><p>补偿机制：比如在电商系统中，如果订单服务创建订单成功，但账户服务扣减余额失败，可以通过补偿机制，创建一个退款订单，退还用户的余额，从而修正数据不一致的问题。</p></blockquote></li><li><p><strong>CP 方案</strong>：各个子事务执行后，不立即提交，而是通过<strong>协调者</strong>来统一管理各个子事务的提交或回滚，确保所有子事务<strong>同时提交或回滚</strong>，实现<strong>强一致性</strong>。但在事务执行过程中，可能会出现阻塞或不可用的情况。</p><p><img src="'+T+'" alt="" loading="lazy"></p></li></ul>',20))])}const D=o(S,[["render",z]]);export{V as __pageData,D as default};
