# MySQL
## B+ 树可以存放多少行数据
这里我们先假设 B+ 树高为 2，即存在一个根节点和若干个叶子节点，那么这棵 B+ 树的存放总记录数为：根节点指针数 * 单个叶子节点记录行数。
上文我们已经说明单个叶子节点（页）中的记录数 =16K/1K=16。（这里假设一行记录的数据大小为 1k，实际上现在很多互联网业务数据记录大小通常就是 1K 左右）。
那么现在我们需要计算出非叶子节点能存放多少指针？
其实这也很好算，我们假设主键 ID 为 bigint 类型，长度为 8 字节，而指针大小在 InnoDB 源码中设置为 6 字节，这样一共 14 字节，我们一个页中能存放多少这样的单元，其实就代表有多少指针，即 16384/14=1170。
那么可以算出一棵高度为 2 的 B+ 树，能存放 1170*16=18720 条这样的数据记录。
根据同样的原理我们可以算出一个高度为 3 的 B+ 树可以存放： 1170*1170*16=21902400 条这样的记录。
所以在 InnoDB 中 B+ 树高度一般为 1-3 层，它就能满足千万级的数据存储。
在查找数据时一次页的查找代表一次 IO，所以通过主键索引查询通常只需要 1-3 次 IO 操作即可查找到数据。
## 三大日志流程
![img.png](img.png)
## 主从复制延迟
「半同步复制」（MySQL 5.5+）：主库写 binlog 后，需等待至少一个从库 IO 线程确认接收 binlog，再返回客户端 —— 解决异步复制的数据丢失问题，适合金融等对一致性要求高的场景

1. MySQL 5.6 版本以后，提供了一种「并行复制」的方式，通过将 SQL 线程转换为多个 work 线程来进行重放
2. 「提高从库机器配置」
3. 多个从库分担读压力，分析从库慢查询 
4. 在业务初期就选择合适的分库、分表策略，「避免单表单库过大」带来额外的复制压力 
5. 「避免长事务」 
6. 「避免让数据库进行各种大量运算」 
7. 延迟感知路由，应用层或中间件（如 ShardingSphere、MyCAT）根据延迟决定是否读从库
   - 延迟 < 1s → 允许读从库
   - 延迟 > 5s → 强制读主库
   - 对强一致性要求高的请求（如支付后查订单），直接读主库
8. 半同步复制：
   至少 1 个从库收到 Binlog 后，主库才返回成功
   不能减少延迟，但能保证故障切换时数据不丢
9. 紧急处理：
   - 读主库
   - 检查问题 SHOW PROCESSLIST：是否有大查询阻塞，iotop / top：从库 IO/CPU 是否打满
   - 重建从库（终极手段）

## 前模糊匹配索引失效如何解决
MySQL 8.0 索引跳跃扫描 联合索引将第一个字段分区

解决办法：
- 反向索引：将索引字段的值额外存储一份，不过值是经过反转后处理的，当查询时，将前模糊匹配也转成后模糊匹配
- 限制范围：如果可以增加额外的条件来过滤掉一部分，也可以提高性能
- 索引覆盖：如果查询结果刚好是索引字段，即使是全表扫描，也无需再回表，这样也可以提升一些性能
> 如果上述都不满足：则可以将数据同步到es，进行模糊查询
## 死锁解决方案

- 保持加锁的顺序
- 减少事务粒度
- 设置锁超时时间
- where条件走唯一索引
- 如果业务允许走 RC 隔离级别关闭间隙锁
- mysql本身会自动检测死锁，发生时会回滚一个代价最小的事务，