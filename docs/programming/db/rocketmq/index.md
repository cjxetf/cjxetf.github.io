# RocketMQ 集群原理


## 一、 集群核心角色分工（各司其职，支撑集群运转）

RocketMQ 集群由多个核心组件构成，每个组件承担特定职责，协同完成消息的生产、存储、消费全链路，核心角色包括：

### 1. NameServer（命名服务 / 注册中心）

* ​**核心定位**​：无状态、轻量级的注册中心，相当于集群的 “导航台”，不存储消息数据，仅维护集群的元数据信息。
* ​**核心职责**​：
   1. 接收 Broker 节点的注册（Broker 启动后会定期向所有 NameServer 上报自身信息，包括 Broker 地址、所属集群、存储的 Topic 队列信息等）。
   2. 为 Producer（生产者）和 Consumer（消费者）提供元数据查询服务（比如 Producer 发送消息前，会先向 NameServer 查询目标 Topic 对应的 Broker 地址，再直接与 Broker 通信）。
   3. 无主从、无集群共识（多个 NameServer 之间互不通信，依赖 Broker 主动上报实现数据同步），支持水平扩展，部署多个节点提升可用性（避免单点故障）。

### 2. Broker（消息代理 / 存储节点）

* ​**核心定位**​：集群的核心节点，消息的 “存储仓库” 和 “转发中心”，所有消息的生产、存储、消费都直接与 Broker 交互。
* ​**核心职责**​：
   1. 接收 Producer 发送的消息，完成消息的持久化存储（写入磁盘文件或内存）。
   2. 处理 Consumer 的消息拉取 / 推送请求，将消息分发给消费者。
   3. 维护消息的生命周期（过期删除、重试、死信队列等）。
   4. 向 NameServer 定期上报元数据（默认 30 秒一次），更新自身状态。
* ​**关键细分**​：Broker 节点内部又分为 `Master`（主节点）和 `Slave`（从节点），主从配合实现数据高可用，后续会详细说明。

### 3. Producer（消息生产者）

* ​**核心定位**​：消息的发送方，负责生成并发送消息到 Broker 集群。
* ​**核心特性**​：
   1. 无状态，不与集群建立长连接（仅发送消息时与目标 Broker 建立短连接，或通过连接池复用连接）。
   2. 发送前先向 NameServer 查询 Topic 元数据，获取对应的 Broker 队列信息，直接与 Broker 通信（不经过 NameServer 转发，提升传输效率）。
   3. 支持多种发送模式（同步、异步、单向），并通过负载均衡策略将消息分发到 Topic 的不同队列中。

### 4. Consumer（消息消费者）

* ​**核心定位**​：消息的接收方，负责从 Broker 集群拉取（主流）或接收推送的消息，并进行业务处理。
* ​**核心特性**​：
   1. 同样先向 NameServer 查询 Topic 对应的 Broker 信息，再直接与 Broker 交互。
   2. 支持集群消费和广播消费两种模式，通过消费者组（Consumer Group）实现消费负载均衡和消息幂等性保障。
   3. 会维护消费偏移量（Offset），记录已消费的消息位置，避免重复消费或消息丢失。

## 二、 核心集群部署模式（不同场景适配不同架构）

RocketMQ 提供了多种集群部署模式，核心分为以下 3 种，其中 \*\* 主从集群（多主多从）\*\* 是生产环境的主流选择：

### 1. 单 Master 模式（仅测试 / 演示使用）

* ​**架构**​：仅部署 1 个 Broker Master 节点，无 Slave 节点。
* ​**特点**​：部署简单、资源消耗低，但存在严重的单点故障问题（Master 节点宕机后，整个集群无法提供消息存储和消费服务，消息可能丢失），​**严禁用于生产环境**​。

### 2. 多 Master 模式（无从节点，适用于非核心业务）

* ​**架构**​：部署多个独立的 Master 节点（比如 3 个、4 个），每个 Master 节点对应不同的 Broker 组，无 Slave 节点。
* ​**特点**​：
   1. 水平扩展能力强，单个 Master 节点宕机，仅影响该节点上的 Topic 队列，其他 Master 节点仍可正常工作，整体可用性高于单 Master 模式。
   2. 缺点：宕机的 Master 节点上未被消费的消息，在节点恢复前无法被消费；若 Master 节点磁盘损坏，会导致该节点上的消息永久丢失，不具备数据容错能力。
* ​**适用场景**​：非核心业务、对消息丢失容忍度较高的场景。

### 3. 多 Master 多 Slave 模式（生产环境首选，核心架构）

* ​**架构**​：每个 Master 节点对应 1 个或多个 Slave 节点（常见 1 Master + 1 Slave），形成一组主从节点；多个主从组构成完整集群（比如 3 主 3 从）。
* ​**核心特点**​：
   1. ​**高可用**​：Master 节点宕机后，Slave 节点可以切换为 Master 节点（手动或自动），继续提供服务，保障集群不中断。
   2. ​**数据容错**​：Master 节点会将接收到的消息同步给 Slave 节点，实现数据备份，即使 Master 节点磁盘损坏，Slave 节点仍保留完整消息数据，避免消息丢失。
   3. ​**读写分离**​：默认情况下，Producer 仅向 Master 节点发送消息，Consumer 可以从 Master 或 Slave 节点拉取消息，减轻 Master 节点的读取压力，提升集群吞吐量。
* ​**同步模式细分**​：
   * 同步双写（SYNC\_MASTER）：Master 节点接收消息后，必须等待 Slave 节点完成消息同步并返回确认，才向 Producer 返回 “发送成功”。优点：数据一致性最高，几乎无消息丢失；缺点：同步耗时增加，消息发送延迟略高。
   * 异步复制（ASYNC\_MASTER）：Master 节点接收消息并持久化到本地后，立即向 Producer 返回 “发送成功”，随后异步将消息同步给 Slave 节点。优点：消息发送延迟低，吞吐量高；缺点：Master 节点宕机时，可能存在少量未同步到 Slave 节点的消息丢失。
* ​**适用场景**​：核心业务、对消息可靠性和集群可用性要求较高的生产环境，是 RocketMQ 集群的​**标准部署模式**​。

## 三、 数据存储与高可用核心机制（保障消息不丢失、集群不中断）

### 1. 消息存储机制（持久化与备份）

* RocketMQ 的消息采用​**磁盘持久化存储**​（避免内存溢出和消息丢失），存储结构分为三层：Topic（主题）→ Queue（队列）→ CommitLog（提交日志）。
   1. 逻辑层面：每个 Topic 可以划分为多个队列（默认 4 个），队列分布在不同的 Broker 节点上，实现消息的负载均衡和并行处理。
   2. 物理层面：所有 Topic 的消息都混合存储在 Broker 的 CommitLog 文件中（统一存储，提升磁盘 IO 效率），通过索引文件（ConsumeQueue、IndexFile）快速定位消息位置。
* 主从数据同步：Master 节点的 CommitLog 文件更新后，会通过 “日志复制” 机制将增量数据同步给 Slave 节点，Slave 节点接收后，会复刻与 Master 节点完全一致的 CommitLog 和索引文件，保证数据一致性。

### 2. 高可用核心保障（主从切换与故障容错）

* ​**Broker 状态检测**​：NameServer 会定期接收 Broker 节点的心跳上报（默认 30 秒），若超过一定时间（默认 120 秒）未收到某个 Broker 节点的心跳，NameServer 会将该节点标记为 “不可用”，并更新元数据，后续 Producer 和 Consumer 不会再向该节点发送 / 拉取消息。
* ​**主从切换**​：当 Master 节点宕机后，有两种切换方式：
   1. 手动切换：运维人员通过 RocketMQ 命令行工具，将对应的 Slave 节点升级为 Master 节点，更新集群配置后，NameServer 感知到新的 Master 节点，后续流量切换到新节点。
   2. 自动切换：借助 RocketMQ 的 Dledger 技术（分布式账本），实现主从节点的自动选主和数据同步，Master 节点宕机后，Slave 节点会快速自动升级为 Master 节点，无需人工干预，进一步提升集群可用性（目前已成为生产环境的主流配置）。

## 四、 请求路由与负载均衡（提升集群吞吐量和资源利用率）

### 1. 路由流程（基于 NameServer 的元数据导航）

1. ​**Broker 注册**​：Broker 启动后，向所有 NameServer 节点上报自身元数据（Broker 地址、集群名称、Topic 队列配置等），并定期发送心跳更新状态。
2. ​**Producer/Consumer 查询元数据**​：Producer 发送消息、Consumer 拉取消息前，会随机向一个 NameServer 节点发送请求，查询目标 Topic 对应的 Broker 队列信息。
3. ​**直接与 Broker 通信**​：获取元数据后，Producer/Consumer 直接与对应的 Broker 节点建立连接，完成消息的发送或拉取，后续无需再经过 NameServer（仅在元数据变更时，重新查询 NameServer）。

### 2. 负载均衡策略（合理分配流量，避免单点过载）

* ​**Producer 端负载均衡**​：Producer 针对每个 Topic，会根据 Broker 队列的分布情况，采用 “轮询” 或 “随机” 策略，将消息均匀分发到该 Topic 的所有可用队列中（队列分布在不同 Broker 节点上），避免单个队列或 Broker 节点过载，提升消息发送的吞吐量。
* ​**Consumer 端负载均衡**​：以消费者组（Consumer Group）为单位，同一个消费者组内的多个 Consumer 实例，会通过 “平均分配” 或 “一致性哈希” 等策略，分摊该消费者组订阅的 Topic 队列（每个队列仅被同一个消费者组内的一个 Consumer 实例消费），避免重复消费，同时提升消费并行度。

## 总结

1. RocketMQ 集群的核心是​**NameServer（导航）+ Broker（存储 / 转发）**​，Producer 和 Consumer 依赖 NameServer 找到 Broker，直接与 Broker 交互。
2. 生产环境首选​**多 Master 多 Slave 模式**​（搭配 Dledger 自动切换），通过主从同步实现数据容错，保障集群高可用。
3. 核心机制包括：元数据注册与查询、消息持久化与主从同步、主从切换、端到端的负载均衡，共同支撑集群的高性能、高可靠运行。
4. 集群无中心节点（NameServer 无状态、Broker 主从组独立），具备良好的水平扩展能力，可根据业务流量灵活扩容。
