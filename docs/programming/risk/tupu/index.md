# 知识图谱是什么

## 知识是什么？

知识图谱（Knowledge Graph）正如其名，其本质是为了表示知识。那么知识是该如何定义呢？我们来看一下维基百科中的定义：

> 知识是对某个主题确信的认识，并且这些认识拥有潜在的能力为特定目的而使用。意指透过经验或联想，而能够熟悉进而了解某件事情；这种事实或状态就称为知识，其包括认识或了解某种科学、艺术或技巧。此外，亦指透过研究、调查、观察或经验而获得的一整套知识或一系列资讯。

可以从这块相对抽象的定义里得到一个主观的感受，那就是知识是一种认知，其既是一种事实，也是一种状态。比如，“我会加减乘除”是一种事实也是在表述我通过学习和实践，使得现在已经掌握这项技能的一种状态。并且这种认知是相对复杂的，有从时间变化的纵向维度，也有涉及到关系、概念、实践等等横向维度的变化。但不变的是，知识是有一个主题的，以及由主题衍生出来的各个“属性”组成，类似于树状结构，这一棵树，就是一条知识。

如果用官方一点的定义呢，每条知识是表示为一个 SPO 三元组，即 Subject（主体）Predicate（谓语）Object（客体）

那个回到“表示知识”这个关键点，我们创造出知识图谱这个概念，就是为了帮助我们更快、更好地用来表示出多条独立的“知识”。更进一步说，知识图谱就是用来组织和描述 SPO 三元组的。

## 如何描述三元组？

前面我们介绍了知识的概念和SPO三元组，我们已经知道了，知识图谱是一条条知识组成的，一条条知识又是三元关系（Subject——Predicate——>Object）组成的，那么问题就来了，如何描述这个三元关系呢？

### 使用RDF来表示

在知识图谱中，我们用RDF形式化地表示这种三元关系。从定义上来看，RDF(Resource Description Framework)，即资源描述框架，是W3C制定的，用于描述实体/资源的标准数据模型。[1] 为什么我们描述知识要用“Web”的形式去描述呢？因为网络、Web中的各项关系，其实和知识的抽象概念很像，这是一种即像树，又像网的东西。

有唯一确定主体、有连接属性的谓语、有明确属性值。

那么RDF框架下，对三元组是如何具体定义的呢？我们先来了解一下RDF图中定义的三种类型：International Resource Identifiers(IRIs)，blank nodes 和 literals[1]。RDF通过定义出来的这三种属性对SPO三元组进行约束：

> Subject可以是IRI或blank node。Predicate是IRI。Object三种类型都可以。

可以看到，主体必须是能唯一表示的，或者干脆就是匿名资源（Blank Node，这个概念可以向外引申，在这里可以先忽略）。唯一表示就会用到IRI，相当于是URL和URI的推广[1]，用于唯一定义一个实体或是资源。（说白了，就是我们要通过一个确定的方式来找到唯一的它）

谓语也是要唯一表示的，就像你都不知道要和另一个人建立什么关系，你又怎么能跑过去说我们在一起吧。这个“在一起的两个人“这个关系描述得就太模糊，不能唯一确定。举个例子，两个男的可以是朋友、可以是仇人也可以是情侣。

那我们整理一下RDF定义三种类型的用处：

* IRI —— 在整个网络或者图中唯一定义了一个实体/资源
* blank node —— 没有IRI和literal的资源，或者说匿名资源[1]，暂不详细分析
* literal —— 字面量，可以看作是带有数据类型的纯文本

回到刚刚那个例子，架设有两个男人一个为A，一个为B，我们的主体Subject是男人A，我们给他一个IRI：`www.man-a/relation`；我们的谓语是表示与主体是朋友的关系，我们给他一个带有prefix的IRI：`kg:firiends`；然后我们的客体就是男人B的名字，我们给他一个字面量：`man-b`。

那么这个描述两个男人间朋友关系的这个知识就可以表述为：`www.man-a/relation` ——`kg:firiends`——`man-b`。

这就是RDF的作用，使用标准数据模型的方式来进行资源描述。

### 使用属性图来表示

介绍完RDF来表示关系，是不是感觉略有一点复杂，确实，这种方式比较严谨，更贴近知识图谱原始的定义。但实际在工业界应用过程中，还是会有相当多的场景会选择用属性图（Property Graph）的形式来描述“关系”。那么下面我们来介绍一下属性图的方式。

属性图(Property Graph)的逻辑其实特别好理解，就是主体会和很多客体有关系，比如主体是一个普通人A的话，他会有手机号、会有性别、会有家人，这些就是他的客体。而他和他的手机号之间，就是“拥有”的关系、他和他的父亲，就是父子关系，这种关系就是主体和客体的关系。以上三种，主体、关系、客体，都可以有相应的属性。例如普通人A，属性可以是他的名字（也可以成为一种主客体关系）；他和他的手机号之间是拥有的关系，“拥有”关系可以有属性“何时拥有”、”如何拥有“等；手机号也可以有属性，比如归属的运营商名字等等。

这种同样描述主客体关系，但支持实体或关系拥有属性的方式，就称为属性图表示。

## 从知识到知识图谱

我们从知识的定义讲到了如何表示使用RDF定义单条知识，那么知识图谱的具体形象就呼之欲出了，知识图谱就是有多条知识组成的树状或网状结构，总体来说是图的结构。

主体必须唯一确定，谓语需要清楚描述，客体可以是另一条“子知识“也可以是字面量（也就是带数据类型的纯文本）。

以下是一个使用RDF描述的知识图谱，可以看到其通过RDF标准来表示出了单条的知识以及总体的关系：

![](https://steamory.feishu.cn/space/api/box/stream/download/asynccode/?code=MjhhMzYzMTQzOGQ2ZGI5YmI3YjkzMjdhMDg3YjAzNWVfNnNVcXh1SkswOHRWQXNmamhuNEh0bVh4ZlFxSlJBSFlfVG9rZW46Ym94Y25Gbkt5eE9Sc2FXb3VLbG95SWZHTEtjXzE3NjYwNDU2NDU6MTc2NjA0OTI0NV9WNA)

图：罗纳尔多知识图谱[1]

以下是一个由属性图来表示的知识图谱，注意其支持实体或关系拥有属性，而RDF形式的就不支持：

![](https://steamory.feishu.cn/space/api/box/stream/download/asynccode/?code=MmY2MWQzOTNkYmNiNTE4YzQ1Njc3MGRmOGI0OTE5NTJfem1hSW1yRWhkWDZmbFloMGtISTZLbk9SdWRQYWw2VktfVG9rZW46Ym94Y25Gd3VXU3RldHBmaVJIRWR5ZzBOc2VnXzE3NjYwNDU2NDU6MTc2NjA0OTI0NV9WNA)

图：一个简单的属性图[2]

其实更严谨地说，这两种不同的描述关系的方式，其实也是代表了两种知识图谱的存储方式：

* 基于RDF存储的形式
* 基于图数据库的存储

以下是两者之间的比较：

![](https://steamory.feishu.cn/space/api/box/stream/download/asynccode/?code=MWRiMTllZjgxMTg4ZDM3YmFkYzUyZDM1MzNhYjZmODVfWnZ4a2p2RnFVTlR4ck1VaXVBYkNidkxGcVZyY0wwNVhfVG9rZW46Ym94Y25mNTdMdjVDT2ZZVnVRdlgwZ29XNlFiXzE3NjYwNDU2NDU6MTc2NjA0OTI0NV9WNA)

图：RDF和图数据库方式的比较[2]

## 知识图谱的作用

> 知识图谱提供了从“关系”的角度去分析问题的能力。 知识图谱这个概念最早由Google提出，主要是用来优化现有的搜索引擎。 不同于基于关键词搜索的传统搜索引擎，知识图谱可用来更好地查询复杂的关联信息，从语义层面理解用户意图，改进搜索质量。

从这个概念上来说，知识图谱主要解决的问题是一个复杂关联信息的查询和表示。那么我们来看看它的应用需求应该是如何的，换句话说，就是什么样的情况下，我们可以考虑采用知识图谱：

![](https://steamory.feishu.cn/space/api/box/stream/download/asynccode/?code=ZGRjMjY4ZGY1NDdjMWRiMjNmMzlhZWUyNzY2MTYwZGJfYzNqaHZadk1tZUIwVGdKeWtpVEczSk9wVlZWNTlyMkhfVG9rZW46Ym94Y251dWNPYVFNeklUYkZhbDNYY3MxOXFiXzE3NjYwNDU2NDU6MTc2NjA0OTI0NV9WNA)






# 知识图谱的价值和应用

## **一、知识图谱**​**无处不在**

说到人工智能技术，人们首先会联想到深度学习、机器学习技术；谈到人工智能应用，人们很可能会马上想起语音助理、自动驾驶等等，各行各业都在研发底层技术和寻求AI场景，却忽视了当下最时髦也很重要的AI技术：知识图谱。

当我们进行搜索时，搜索结果右侧的联想，来自于知识图谱技术的应用。我们几乎每天都会接收到各种各样的推荐信息，从新闻、购物到吃饭、娱乐。

个性化推荐作为一种信息过滤的重要手段，可以依据我们的习惯和爱好推荐合适的服务，也来自于知识图谱技术的应用。搜索、地图、个性化推荐、互联网、风控、银行……越来越多的应用场景，都越来越依赖知识图谱。

## **二、知识图谱**​**与人工智能的关系**

知识图谱用节点和关系所组成的图谱，为真实世界的各个场景直观地建模。通过不同知识的关联性形成一个网状的知识结构，对机器来说就是图谱。

形成知识图谱的过程本质是在建立认知、理解世界、理解应用的行业或者说领域。每个人都有自己的知识面，或者说知识结构，本质就是不同的知识图谱。正是因为有获取和形成知识的能力，人类才可以不断进步。

知识图谱对于人工智能的重要价值在于，知识是人工智能的基石。机器可以模仿人类的视觉、听觉等感知能力，但这种感知能力不是人类的专属，动物也具备感知能力，甚至某些感知能力比人类更强，比如：狗的嗅觉。

而“认知语言是人区别于其他动物的能力，同时，知识也使人不断地进步，不断地凝练、传承知识，是推动人不断进步的重要基础。” 知识对于人工智能的价值就在于，让机器具备认知能力。

而构建知识图谱这个过程的本质，就是让机器形成认知能力，去理解这个世界。

## **三、图数据库**

知识图谱的图存储在图数据库（Graph Database）中，图数据库以图论为理论基础，图论中图的基本元素是节点和边，在图数据库中对应的就是节点和关系。用节点和关系所组成的图，为真实世界直观地建模，支持百亿量级甚至千亿量级规模的巨型图的高效关系运算和复杂关系分析。

目前市面上较为流行的图数据库有：Neo4j、Orient DB、Titan、Flock DB、Allegro Graph等。不同于关系型数据库，一修改便容易“牵一发而动全身”图数据库可实现数据间的“互联互通”，与传统的关系型数据库相比，图数据库更擅长建立复杂的关系网络。

图数据库将原本没有联系的数据连通，将离散的数据整合在一起，从而提供更有价值的决策支持。

## **四、知识图谱**​**的价值**

知识图谱用节点和关系所组成的图谱，为真实世界的各个场景直观地建模，运用“图”这种基础性、通用性的“语言”，“高保真”地表达这个多姿多彩世界的各种关系，并且非常直观、自然、直接和高效，不需要中间过程的转换和处理——这种中间过程的转换和处理，往往把问题复杂化，或者遗漏掉很多有价值的信息。

在风控领域中，知识图谱产品为精准揭露“欺诈环”、“窝案”、“中介造假”、“洗钱”和其他复杂的欺诈手法，提供了新的方法和工具。尽管没有完美的反欺诈措施，但通过超越单个数据点并让多个节点进行联系，仍能发现一些隐藏信息，找到欺诈者的漏洞，通常这些看似正常不过的联系（关系），常常被我们忽视，但又是最有价值的反欺诈线索和风险突破口。

尽管各个风险场景的业务风险不同，其欺诈方式也不同，但都有一个非常重要的共同点——欺诈依赖于信息不对称和间接层，且它们可以通过知识图谱的关联分析被揭示出来，高级欺诈也难以“隐身”。

凡是有关系的地方都可以用到知识图谱，事实上，知识图谱已经成功俘获了大量客户，且客户数量和应用领域还在不断增长中，包括沃尔玛、领英、阿迪达斯、惠普、FT金融时报等知名企业和机构。

目前知识图谱产品的客户行业，分类主要集中在：社交网络、人力资源与招聘、金融、保险、零售、广告、物流、通信、IT、制造业、传媒、医疗、电子商务和物流等领域。在风控领域中，知识图谱类产品主要应用于反欺诈、反洗钱、互联网授信、保险欺诈、银行欺诈、电商欺诈、项目审计作假、企业关系分析、罪犯追踪等场景中。

那相比传统数据存储和计算方式，知识图谱的优势显现在哪里呢？

**（1）关系的表达能力强**

传统数据库通常通过表格、字段等方式进行读取，而关系的层级及表达方式多种多样，且基于图论和概率图模型，可以处理复杂多样的关联分析，满足企业各种角色关系的分析和管理需要。

**（2）像人类思考**​**一样去做分析**

基于知识图谱的交互探索式分析，可以模拟人的思考过程去发现、求证、推理，业务人员自己就可以完成全部过程，不需要专业人员的协助。

**（3）知识学习​**

利用交互式机器学习技术，支持根据推理、纠错、标注等交互动作的学习功能，不断沉淀知识逻辑和模型，提高系统智能性，将知识沉淀在企业内部，降低对经验的依赖。

**（4）高速反馈**

图式的数据存储方式，相比传统存储方式，数据调取速度更快，图库可计算超过百万潜在的实体的属性分布，可实现秒级返回结果，真正实现人机互动的实时响应，让用户可以做到即时决策。

## **五、知识图谱**​**的主要技术**

### **5.1 知识建模**

知识建模，即为知识和数据进行抽象建模，主要包括以下5个步骤：

1. 以节点为主体目标，实现对不同来源的数据进行映射与合并。（确定节点）
2. 利用属性来表示不同数据源中针对节点的描述，形成对节点的全方位描述。（确定节点属性、标签）
3. 利用关系来描述各类抽象建模成节点的数据之间的关联关系，从而支持关联分析。（图设计）
4. 通过节点链接技术，实现围绕节点的多种类型数据的关联存储。（节点链接）
5. 使用事件机制描述客观世界中动态发展，体现事件与节点间的关联，并利用时序描述事件的发展状况。（动态事件描述）

### **5.2 知识获取**

从不同来源、不同结构的数据中进行知识提取，形成知识存入到知识图谱，这一过程我们称为知识获取。针对不同种类的数据，我们会利用不同的技术进行提取。

**​从结构化数据库中获取知识：​**D2R。

**​难点：​**复杂表数据的处理。

**从链接数据**​**​中获取知识：​**图映射。

**​难点：​**数据对齐。

**从半结构化（网站）数据**​**​中获取知识：​**使用包装器。

**​难点：​**方便的包装器定义方法，包装器自动生成、更新与维护。

**​从文本中获取知识：​**信息抽取。

**​难点：​**结果的准确率与覆盖率。

![](https://steamory.feishu.cn/space/api/box/stream/download/asynccode/?code=ZjM1NTczZDQwNTYzYzFhNDI1OTM2YTA4YzNkNzQ2N2JfSGxvZWt5MW5lNjlZdk4xUFZ4SGVLR0plTkVHallwMEtfVG9rZW46Ym94Y25PMHp1aGxkdXhWc01BS09GYWtLR2djXzE3NjYwNDU2ODM6MTc2NjA0OTI4M19WNA)

### **5.3 知识融合**

如果知识图谱的数据源来自不同数据结构的数据源，在系统已经从不同的数据源把不同结构的数据提取知识之后，接下来要做的是把它们融合成一个统一的知识图谱，这时候需要用到知识融合的技术（如果知识图谱的数据结构均为结构化数据，或某种单一模式的数据结构，则无需用到知识融合技术）。

知识融合主要分为数据模式层融合和数据层融合，分别用的技术如下：

1. 数据模式层融合：概念合并、概念上下位关系合并、概念的属性定义合并。
2. 数据层融合：节点合并、节点属性融合、冲突检测与解决（如某一节点的数据来源有：豆瓣短文、数据库、网页爬虫等，需要将不同数据来源的同一节点进行数据层的融合）。

由于行业知识图谱的数据模式通常采用自顶向下（由专家创建）和自底向上（从现有的行业标准转化，从现有高质量数据源（如百科）转化）结合的方式，在模式层基本都经过人工的校验，保证了可靠性，因此，知识融合的关键任务在数据层的融合。

### **5.4 知识存储**

图谱的数据存储既需要完成基本的数据存储，同时也要能支持上层的知识推理、知识快速查询、图实时计算等应用，因此需要存储以下信息：三元组（由开始节点、关系、结束节点三个元素组成）知识的存储、事件信息的存储、时态信息的存储、使用知识图谱组织的数据的存储。

其关键技术和难点就在于：

1. 大规模三元组数据的存储；
2. 知识图谱组织的大数据的存储；
3. 事件与时态信息的存储；
4. 快速推理与图计算的支持。

### **5.5 知识计算**

知识计算主要是在知识图谱中知识和数据的基础上，通过各种算法，发现其中显式的或隐含的知识、模式或规则等，知识计算的范畴非常大，这里主要讲三个方面：

1. **​图挖掘计算：​**基于图论的相关算法，实现对图谱的探索和挖掘。
2. **​本体推理：​**使用本体推理进行新知识发现或冲突检测。
3. **基于规则**​**​的推理：​**使用规则引擎，编写相应的业务规则，通过推理辅助业务决策。

### **5.6 图挖掘和图计算**

知识图谱之上的图挖掘和计算主要分以下6类：

* 第一是图遍历，知识图谱构建完之后可以理解为是一张很大的图，怎么去查询遍历这个图，要根据图的特点和应用的场景进行遍历；
* 第二是图里面经典的算法，如最短路径；
* 第三是路径的探寻，即给定两个实体或多个实体去发现他们之间的关系；
* 第四是权威节点的分析，这在社交网络分析中用的比较多；
* 第五是族群分析；
* 第六是相似节点的发现。

### **5.7 可视化技术**

目前两个比较常见的可视化工具是：**D3.js和ECharts。**

* **​D3.js：​**全称Data-Driven Documents，是一个用动态图形显示数据的JavaScript库，一个数据可视化工具，它提供了各种简单易用的函数，大大方便了数据可视化的工作。
* **​ECharts：​**是一款由百度前端技术部开发的，同样基于Javascript的数据可视化图标库。它提供大量常用的数据可视化图表，底层基于ZRender（一个全新的轻量级canvas类库），创建了坐标系、图例、提示、工具箱等基础组件，并在此上构建出折线图（区域图）、柱状图（条状图）、散点图（气泡图）、饼图（环形图）、K线图、地图、力导向布局图以及和弦图，同时支持任意维度的堆积和多图表混合展现。

## **六、知识图谱**​**的应用**

知识图谱的应用场景很多，除了问答、搜索和个性化推荐外，在不同行业不同领域也有广泛应用，以下列举几个目前比较常见的应用场景。

### **6.1 信用卡申请反欺诈图谱**

**6.1.1 欺诈手法**

银行信用卡的申请欺诈包括个人欺诈、团伙欺诈、中介包装、伪冒资料等，是指申请者使用本人身份或他人身份或编造、伪造虚假身份进行申请信用卡、申请贷款、透支欺诈等欺诈行为。

欺诈者一般会共用合法联系人的一部分信息，如电话号码、联系地址、联系人手机号等，并通过它们的不同组合创建多个合成身份。比如：3个人仅通过共用电话和地址两个信息，可以合成9个假名身份，每个合成身份假设有5个账户，总共约45个账户。假设每个账户的信用等级为20000元，那么银行的损失可能高达900000元。

由于拥有共用的信息，欺诈者通过这些信息构成欺诈环。

一开始，欺诈环中的账户使用正常，欺诈者会进行正常的购买、支付和还款行为，这种行为称为“养卡”。“养卡”了一段时间后，信用额度会有所增加，随着时间推移会增长到一个让欺诈者相对“满意”的额度。

突然有一天欺诈环“消失”了，环内成员都最大化地使用完信用额度后跑路了。

**6.1.2 ​知识图谱**​**解决信用卡申请反欺诈问题**

使用传统的关系数据库，来揭露欺诈环需要技术人员执行一系列的复杂连接和自连接，而且查询构建起来非常复杂，查询效率低、速度慢且成本高。

知识图谱产品利用图数据库的天然优势，直接将银行欺诈环节可能涉及的所有有用的数据字段：如申请号、账户、身份证、手机、地址、家庭电话、联系人、设备指纹等设计成图谱的节点，定义好图谱所需的所有节点和节点属性后，定义两两节点间的关系。

如：申请号节点与设备指纹节点相连构成“申请设备”关系，人节点与地址节点相连构成“申请人地址”关系。

根据业务上设计好的图谱进行建图，建图后，用户可以直接在关联图谱平台上，输入某个节点值查询节点的关联信息，如：输入某个黑手机号，看其关联5层范围内的涉及到的申请人信息，看该节点是否与其他节点关联成欺诈环，看节点与历史的黑节点间是否有过关联等等。

用户可借助知识图谱产品，在贷前防御风险，贷中进行关联分析找出可疑点，控制风险，贷后进行风险把关，让损失降到最低。

### **6.2 企业知识图谱**

目前金融证券领域，应用主要侧重于企业知识图谱。企业数据包括：企业基础数据、投资关系、任职关系、企业专利数据、企业招投标数据、企业招聘数据、企业诉讼数据、企业失信数据、企业新闻数据等。

利用知识图谱融合以上企业数据，可以构建企业知识图谱，并在企业知识图谱之上利用图谱的特性，针对金融业务场景有一系列的图谱应用，举例如下：

**（1）企业风险**​**评估**

基于企业的基础信息、投资关系、诉讼、失信等多维度关联数据，利用图计算等方法构建科学、严谨的企业风险评估体系，有效规避潜在的经营风险与资金风险。

**（2）企业社交图谱查询**

基于投资、任职、专利、招投标、涉诉关系以目标企业为核心向外层层扩散，形成一个网络关系图，直观立体展现企业关联。

**（3）企业最终控制人查询**

基于股权投资关系寻找持股比例最大的股东，最终追溯至某自然人或国有资产管理部门。

**（4）企业之间路径发现**

在基于股权、任职、专利、招投标、涉诉等关系形成的网络关系中，查询企业之间的最短关系路径，衡量企业之间的联系密切度。

**（5）初创企业融资发展历程**

基于企业知识图谱中的投融资事件发生的时间顺序，记录企业的融资发展历程。

**（6）上市**​**企业智能问答**

用户可以通过输入自然语言问题，系统直接给出用户想要的答案。

### **6.3 交易知识图谱**

金融交易知识图谱在企业知识图谱之上，增加交易客户数据、客户之间的关系数据以及交易行为数据等，利用图挖掘技术，包括很多业务相关的规则，来分析实体与实体之间的关联关系，最终形成金融领域的交易知识图谱。

在银行交易反欺诈方面，可以从从身份证，手机号、设备指纹、IP等多重维度对持卡人的历史交易信息进行自动化关联分析，关联分析出可疑人员和可疑交易。

### **6.4 反洗钱知识图谱**

对于反洗钱或电信诈骗场景，知识图谱可精准追踪卡卡间的交易路径，从源头的账户/卡号/商户等关联至最后收款方，识别洗钱/套现路径和可疑人员，并通过可疑人员的交易轨迹，层层关联，分析得到更多可疑人员、账户、商户或卡号等实体。

### **6.5 信贷/消费**​**贷知识图谱**

对于互联网信贷、消费贷、小额现金贷等场景，知识图谱可从身份证、手机号、紧急联系人手机号、设备指纹、家庭地址、办公地址、IP等多重维度对申请人的申请信息，进行自动化关联分析，通过关系关系并结合规则，识别图中异常信息，有效判别申请人信息真实性和可靠性。

### **6.6 内控知识图谱**

在内控场景的经典案例里，中介人员通过制造或利用对方信息的不对称，将企业存款从银行偷偷转移，在企业负责人不知情的情况下，中介已把企业存在银行的全部存款转移并消失不见。通过建立企业知识图谱，可将信息实时互通，发现一些隐藏信息，寻找欺诈漏洞，找出资金流向。



# 知识图谱与机器学习如何结合
[图片]
一、知识图谱产生图特征，从关系角度丰富特征工程，提升模型效果，使决策更精准高效
数据决定了模型的上限，特征宽表则从各个纬度去刻画数据特征，在机器学习过程中，特征工程的构建是建模最重要的环节之一。
常规的行为类、交易类、时序类、高频类等特征很容易从数据中挖掘，而关联类特征则需要数据分析师在脑海中推演可能的关联情况和关系网络构成，且需要通过多次join来验证，涉及三度及其以上的多度关联时，无论是脑海推演过程抑或join逻辑都比较复杂。
如果事先构建好图Schema（实体类型&关系类型及其属性），通过知识图谱直接抽取关联特征就方便很多，在实践中证明，其余条件保持不变的情况下，丰富图特征后，可以一定程度上提高模型的K-S、AUC值，某些用户画像、智能营销推荐、信贷、反欺诈等场景下效果显著。
通过图特征丰富特征宽表，全面刻画样本表现情况，提高模型效果是目前知识图谱和机器学习结合方式中最常见也是实践最多的一种方式。
[图片]
二、机器学习提供学习结果，丰富和增强图谱知识，使图谱更智能化
机器学习的本质是通过学习历史数据和经验得到未来的预测结果，通过学习而得到的预测结果本质也是一种“知识”，只是这类知识的准确性是个概率值。
当我们将机器通过学习而得来的知识输入到图谱中，在一定程度上丰富和增强图谱知识，可以使图谱更智能化。
例如，在原生图数据库中，我们知道用户的基本信息，却不知道这个人的信用分、行为分、欺诈分是多少，而机器学习提供的学习结果使我们对“人”这个实体的认知更丰富了，知识图谱增强了知识储备，这个时候再通过图表征（graph embading）得到更智能化的结果。
三、知识图谱结合机器学习，基于已有数据输出全用户画像
在刻画全面用户画像场景下，知识图谱和机器学习往往需要结合使用。
我们知道万事万物都由形形色色的关系构成，知识图谱所产生的关于“人”实体的标签和人与人之间的关系是“用户画像”的基本元素，机器学习、数据服务等产生的标签也是用户画像的重要组成部分。
当然在全面用户画像场景下，遵循元素越多越好的原则：关联关系越多越好，模型产生的标签越多越好，数据纬度也是越多越好。
基于知识图谱、机器学习、数据服务等综合纬度的结合，让我们更了解我们的用户，更清楚他的喜好和习惯，然后更好地为他服务（让他买买买）。
[图片]
[图片]
四、机器学习辅助社团划分，交叉验证定位欺诈团伙
第四种方式较适用于团伙欺诈场景，从业务视角看，一般社团划分所得社团中涉黑占比较高且社团成员数量适中的会被初步划分为可疑社团，业务人员再从可疑社团中进行逐一排查得到欺诈团伙。
然而当知识图谱进行社团划分（常见的社团划分图算法有：louvian、lpa标签传播等）的样本中没有黑样本或黑样本极少时，一方面图谱只能通过原生关系进行聚类得到社团，另一方面业务人员初步的“可疑社团”范围也无法圈定。
这个问题一般有三种解法，一是人为手工打标，通过人为经验给样本打标，该方式费时费力，一般不会采取除非资源足够；二是通过制定规则（策略）识别出黑样本或可疑样本后进行打标；三是通过机器学习模型得到可疑样本，并将阈值大于x（如0.6）的样本默认打标再输入到知识图谱中进行社团划分。
第三种解法即为本文中机器学习与知识图谱结合的第四种方式—“机器学习产生样本标签，辅助图谱社团划分，寻找欺诈团伙”。
在欺诈团伙场景，还有种结合方式是：知识图谱产生的可疑社团成员，通过模型来进行验证。
例如图谱产生某可疑社团中有200个成员，而模型对这200个成员的预测结果大多数为黑，则可大程度上认为该社团为欺诈社团。当然也可以反着来，通过模型预测得到的黑成员里，对应在图谱上的划分情况如何，有哪些成员是在图谱的可疑社团里面。通过这类交叉验证的结合方式，可以帮助我们定位可疑社团、得到欺诈团伙。
五、知识图谱产生黑名单，丰富机器学习黑样本
前文提到的“大数据分析、机器学习建模相关的朋友”说起，目前机器学习的痛点之一是缺乏黑样本、很多场景下建模无法获取黑名单，这时就可以通过知识图谱的关联关系，通过一度、二度或多度关联得到网络中的可疑名单，再加上业务专家经验得到更多黑名单，扩展后的黑名单作为机器学习（这里主要是有监督类）的标签样本输入，一定程度上可以较大提高模型效果。


Neo4j:知识图谱图数据库基础
# Neo4j 与 使用 SQL 的 DB 有何不同？

[知识图谱定义](https://steamory.feishu.cn/wiki/wikcnsCzYdPLMMBeIEtnshfABgf)这一节我们提到了如何去表示知识图谱中一条知识的(使用Subject -> Predicate -> Object)，具体在图数据库中使用时，也是用这样一条数据去表示一条记录的。

​**(cust:Customer**​​**)-[:ISSUED]->(o:Order)**​,这里圆括号表示实体，方括号内表示了 Predicate 关系

Neo4j 在原生图形数据库的支持下，Neo4j 以更自然的连接状态存储和管理数据，维护数据关系，提供闪电般的查询、更深入的分析上下文和轻松的可修改数据模型。作为图形数据库类别的创造者和领导者，Neo4j继续扩展图形技术的限制，帮助最大的活跃社区增强能力，Neo4j 正在努力解决世界上最复杂和最有价值的数据问题。

Neo4j是由庞大的、可用于生产的算法库和先进的、突破性的机器学习工作流提供的。

相比于 SQL 的多表链接，Neo4j 的查询语句简洁而高效，我们先来看看 SQL 这样表达的语句：

```SQL
SELECT p.ProductName
FROM Product AS p
JOIN ProductCategory pc ON (p.CategoryID = pc.CategoryID AND pc.CategoryName = "Dairy Products")

JOIN ProductCategory pc1 ON (p.CategoryID = pc1.CategoryID)
JOIN ProductCategory pc2 ON (pc1.ParentID = pc2.CategoryID AND pc2.CategoryName = "Dairy Products")

JOIN ProductCategory pc3 ON (p.CategoryID = pc3.CategoryID)
JOIN ProductCategory pc4 ON (pc3.ParentID = pc4.CategoryID)
JOIN ProductCategory pc5 ON (pc4.ParentID = pc5.CategoryID AND pc5.CategoryName = "Dairy Products");
```

这一段关系我们可以看出 Product -- part of -> ProductCategory 这样的关系，并且要求多表之间有 CategoryName = "Dairy Products" 这样的限制，因此 Cypher (Neo4j  的查询语言) 可以这样写：

```SQL
MATCH (p:Product)-[:CATEGORY]->(l:ProductCategory)-[:PARENT*0..]->(:ProductCategory {name:"Dairy Products"})
RETURN p.name
```

可以看出 Cypher 是一种强大的、直观的、图形优化的查询语言，能够理解并利用数据连接。它是用户友好的，易于学习的。

# Neo4j Cypher 详细上手手册

目标：

让任何熟悉SQL的人如何编写等效的、高效的Cypher语句。从简单到高级地处理查询。

前置知识：

理解[知识图谱定义](https://steamory.feishu.cn/wiki/wikcnsCzYdPLMMBeIEtnshfABgf)中的知识三元组，即如何去描述一个图模型，例如这是一条知识：

![](https://steamory.feishu.cn/space/api/box/stream/download/asynccode/?code=YzcxZTgyMWUwMThkNGI0M2M3NGZhMmU5MzNlNDE3NGVfS0FYem95UVVJdllaUW5PeXdZTWlDWjNQcGo1QXJ3M2hfVG9rZW46Ym94Y25URkdQSnJoZmkxcGViV2dKSHBuMURjXzE3NjYwNDc5ODY6MTc2NjA1MTU4Nl9WNA)

Node 用于描述 Subject  和 Object，Relationship 在这个图中是 loves 这个关系

如果到这里都没什么问题，那我们正式开始介绍 Cypher:

1. 用圆括号表示节点实体，就像这样:(p:Product)。
2. 关系的箭头是这样绘制的—>，可以在方括号中添加关系类型和其他信息

—[:order]→。`(cust:Customer)-[:ISSUED]->(o:Order)-[:CONTAINS]->(prod:Product)`这个例子表示顾客发起订单，订单中包含产品这样的图关系

以 NorthWind 数据库实例来讲解后续 SQL 与 Cypher 的区别，有助于我们理解 Cypher，ER图如下：

![](https://steamory.feishu.cn/space/api/box/stream/download/asynccode/?code=ZjEzZTY2OTVkZWU2NmIxNzk3MDNlOTAwYjY3MzczYmVfVXZXbWh4WUtROHVNSURtMklZdlBBVnllbU80REpXaXFfVG9rZW46Ym94Y25hbEdqTjM0M2RlM3poeVNtWWRzRU9kXzE3NjYwNDc5ODY6MTc2NjA1MTU4Nl9WNA)

图模型如下：

![](https://steamory.feishu.cn/space/api/box/stream/download/asynccode/?code=MDFlMjNlM2IxZjA0MmQwZWE1ZTFjYWI3NmVlYTBiOTVfcFlUajRXa3JpWEUxTjFMSnEyZlpETmRBZDVwSThTYTNfVG9rZW46Ym94Y244S2hMdEJ1UHF6TzN3YWRiY1RGZ0dnXzE3NjYwNDc5ODY6MTc2NjA1MTU4Nl9WNA)

查找并返回记录：

```SQL
-- SQL --
SELECT p.*
FROM products as p;

-- Cypher --
MATCH (p:Product)
RETURN p;
```

排序和分页返回记录：

```SQL
-- SQL --
SELECT p.ProductName, p.UnitPrice
FROM products as p
ORDER BY p.UnitPrice DESC
LIMIT 10;

-- Cypher --
MATCH (p:Product)
RETURN p.productName, p.unitPrice
ORDER BY p.unitPrice DESC
LIMIT 10;
```

条件过滤：

```SQL
-- SQL --
SELECT p.ProductName, p.UnitPrice
FROM products AS p
WHERE p.ProductName = 'Chocolade';

-- Cypher --
MATCH (p:Product)
WHERE p.productName = "Chocolade"
RETURN p.productName, p.unitPrice;

-- 以上 Cypher 可以简便写为 --
MATCH (p:Product {productName:"Chocolade"})
RETURN p.productName, p.unitPrice;
```

创建索引，加速搜索：

```SQL
-- Cypher --
CREATE INDEX ON :Product(productName);
CREATE INDEX ON :Product(unitPrice);
```

In 过滤：

```SQL
-- SQL --
SELECT p.ProductName, p.UnitPrice
FROM products as p
WHERE p.ProductName IN ('Chocolade','Chai');

-- Cypher --
MATCH (p:Product)
WHERE p.productName IN ['Chocolade','Chai']
RETURN p.productName, p.unitPrice;
```

模糊匹配和大小关系过滤：

```SQL
-- SQL --
SELECT p.ProductName, p.UnitPrice
FROM products AS p
WHERE p.ProductName LIKE 'C%' AND p.UnitPrice > 100;

-- Cypher --
MATCH(p:products)
WHERE p.productName STARTS WITH 'C' AND p.unitPrice > 100 -- 也可以用正则 p.productName =~ "^C.*"
RETURN p.productName, p.unitPrice
```

多表联合查询：

```SQL
-- SQL --
SELECT DISTINCT c.CompanyName
FROM customers AS c
JOIN orders AS o ON (c.CustomerID = o.CustomerID)
JOIN order_details AS od ON (o.OrderID = od.OrderID)
JOIN products AS p ON (od.ProductID = p.ProductID)
WHERE p.ProductName = 'Chocolade';

-- Cypher --
MATCH (c:Customer)-[:PURCHASED]->(:Order)-[:PRODUCT]->(p:Product {productName:"Chocolade"})
RETURN distinct c.companyName;
```


