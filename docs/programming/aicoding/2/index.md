# Spec Coding

>核心观点
> 
>纯粹的Vibe Coding效果非常不可控，最终效果的好坏完全取决于个人驾驭AI的能力，在一些生产级项目上滥用很可能留下巨大的技术债务，将成本从开发阶段转移到了调试、测试和部署等后续环节。
拥抱Spec Coding，通过一套标准的规范化的工作流程，让团队开发同学都能利用AI生成高质量、可维护的生产级代码。



## 什么是Spec Coding

- Spec指的是规范（Specification），Spec Coding是一种"规范优先"的AI辅助编程方法。其核心思想是：与AI的第一次交互不是要求它写代码，而是让它协助构建完整的需求规范。
- 在这种模式下，AI首先扮演资深需求分析师的角色，主动引导开发者：
  - 澄清功能边界和核心需求
  - 识别潜在的技术风险点
  - 明确非功能性需求（性能、安全等）
  - 确定验收标准和测试策略
- 开发者的职责转变为规划者和审核者：专注于定义"做什么"，并为"如何做"设定技术约束和质量标准。这种分工让AI能够在明确的上下文中生成符合企业标准的代码。
![img.png](img.png)


| **维度/模式** | **Vibe Coding (氛围编程，Prompt->Coding)** | **Spec Coding (规范编程, Prompt->Spec->Coding)** |
| --------------------- | -------------------------------------------------- | -------------------------------------------------------- |
| 质量要求            | 较低，以功能实现为主                             | 较高，对性能和安全有严格要求                           |
| 需求清晰度          | 需求模糊，需要在探索中明确                       | 需求相对明确，通过建立Spec来澄清                       |
| 长期维护            | 一次性项目、短期工具                             | 需要长期演进和持续维护的核心系统                       |
| 技术债容忍度        | 较高，可以接受一定的技术债                       | 较低，需要严格控制技术债                               |
| 开发者技能          | 对编码技能要求较低，更侧重创意                   | 对系统设计、需求分析能力要求较高                       |


## Spec Coding 工作流程

Spec Coding将开发过程组织成一系列清晰的、人与AI强协同的阶段，例如规范、规划、任务、实现，其中一条至关重要的规则是： **在当前阶段未被完全验证之前，绝不进入下一阶段** 。这种机制强制引入了纪律性，确保了每个步骤的质量。

从后端视角来看，Spec Coding 的工作流程包括以下节点。 **每一步由AI完成，但需要人来充分审查** ，human in the loop。

### 2.1 应用原则建立

**目标**:建立应用级别的技术规范和开发约束，为AI提供一致的上下文环境。

**非必选**:若当前工程已有README文档， **则无需重复生成** ，直接跳至 2.2 节进入具体的需求。

在一个Spring工程中维护一个 **README.md文档** ， **内容构成可以包括** ：

**应用描述**:描述该应用的定位、能力等，为AI提供必要的领域知识背景；

**运行环境**:说明支持的JDK、Sping Boot版本、构建工具版本，以及配置项管理原则；

**模块划分**:各个软件包的功能，以及它们之间是如何协作的（接口层、数据层、代理层、服务层等），明确架构约束（如HTTP接口用于前端交互，RPC用于后端服务间通信）；

**技术栈描述**:中间件（Redis、MQ、数据库等）的选型，统一的配置文件结构和参数命名规范；

**依赖服务**:依赖的RPC服务清单及其功能描述，Service Client的代码位置和调用示例；

**开发规范**:命名约定、包结构、注释规范、日志记录标准、异常处理等；

**数据模型**:定义核心数据表角色描述与MySQL DDL语句，以及表间的关联关系。

**测试保障**：单元测试包结构，以及测试规范（如核心服务必须有单测）等。

**使用方式**：在与AI进行Spec Coding对话时，通过引用该文档为AI注入项目上下文，确保生成的代码符合项目标准和团队规范。如果有新的依赖或数据模型引入，需要及时更新。

**生成方式**：可以通过以下提示词让AI扫描工程并生成README.md文档

```
## 角色定义你现在是一名资深的企业级 Java 后端架构师，也是 AI 辅助编程的规范设计者。我正在这个仓库中实践一种叫做「Spec Coding」的方式：先用 README 建立清晰的应用规范和上下文，再让 AI 根据具体的需求编写具体代码。所以你的任务是：**读取并分析当前工程中的代码和配置文件，为该应用生成根目录下的 README.md 规范文档。**请你按下面步骤和结构来工作：-------------------------【一、扫描与分析范围】请主动阅读并归纳以下内容（如果不存在就跳过，并在文档中标记“待补充”）：1. Java 代码：   - src/main/java 下的包结构和主要类（Controller / Service / Repository / Client / Config 等）。   - 识别控制层（如 *Controller, *RestController）、服务层（*Service）、数据访问层（*Repository, Mapper）、Client/Proxy 层（如 FeignClient、Dubbo Reference、gRPC Stub 等）。2. 配置与中间件：   - src/main/resources 下的 application.yml / application-*.yml / bootstrap.yml 等。   - 解析其中关于数据库、Redis、MQ、注册中心、配置中心等中间件的配置。   - 查找是否存在 logback.xml、log4j2.xml 等日志配置文件。3. 持久化与数据模型：   - JPA 实体类、MyBatis 实体和 Mapper、Flyway/Liquibase 脚本、DDL.sql 等。   - 识别核心数据表、主键、重要字段以及表之间的明显关联（外键、命名约定等）。4. 依赖服务：   - 查找 FeignClient 接口、Dubbo 服务引用、gRPC Stub 等。   - 从方法名、注释、请求路径、DTO 名称中推断该 RPC 调用的业务含义。5. 构建与运行环境：   - pom.xml 或 build.gradle 中的关键依赖（Spring Boot 版本、数据库驱动、MQ 客户端、缓存客户端等）。   - 判断项目主要运行环境（JDK 版本、是否使用 Spring Boot、是否打包为可执行 Jar 等）。在分析过程中，如果某些信息无法从现有代码中确定，请务必在 README 中明确标注「TODO」或「待补充」，不要臆造细节。-------------------------【二、README.md 的目标结构】请生成 Markdown 格式的 README.md，使用以下一级标题结构（# / ##）：1. 应用描述   - 用 2～3 段话描述：本应用的定位、服务的对象、主要能力或业务领域。   - 若代码中看不出业务场景，请根据模块名/包名给出“可能的领域范围 + TODO 待业务补充”。2. 模块划分与架构   - 说明整体架构风格（如分层架构：Controller → Service → Repository → Domain / Client）。   - 按包或模块列出：     - 接口层（HTTP API、RPC 暴露接口）所在包及职责；     - 服务层（业务逻辑）所在包及职责；     - 数据访问层（Repository / Mapper）所在包及职责；     - 代理/Client 层（调用外部 RPC 或 HTTP 服务）所在包及职责；     - 公共模块（工具类、通用组件、基础配置）。   - 简要说明各层如何协作，并强调架构约束：     - 例如：前端只能通过 HTTP Controller 访问；     - 后端服务间必须通过某种 RPC Client 访问，而不是直接调数据库等。3. 技术栈与中间件   - 说明主要技术栈：     - Spring Boot / Spring Cloud 版本；     - Web 框架（Spring MVC / WebFlux）；     - 数据访问技术（JPA / MyBatis / MyBatis-Plus 等）。   - 中间件使用情况：     - 数据库（类型、作用）；     - Redis（用途，如缓存、分布式锁、会话等）；     - MQ（如 Kafka、RocketMQ、RabbitMQ，主要用途：异步事件、消息通知等）；     - 其他（如 ES、配置中心、注册中心）。   - 若在配置文件中能看到具体参数或命名规范，请总结出 1～2 条统一规则。   - 给出1个典型的调用示例（若代码已有，请总结；否则提出建议），说明“正确的中间件调用方式”。4. 依赖服务与 Service Client   - 列出当前工程依赖的上游/下游 RPC 或 HTTP 服务：     - 每个依赖服务的名称（根据包/类/接口名推断）；     - 功能简介；     - 对应的 Client 接口或类位置（包名 + 类名）。   - 给出 1～2 个典型的调用示例（用伪代码或真实代码片段），说明“正确的依赖调用方式”。5. 开发规范   - 命名约定：     - 类、包、方法、DTO、VO、Entity 的命名习惯（若代码已有风格，请总结；否则提出建议）。   - 包结构规范：     - 说明新增模块应如何放置（例如按照分层 + 领域划分）。   - 注释规范：     - 对于 Controller、Service、复杂业务方法建议的注释方式（如 Javadoc、中文说明）。   - 日志规范：     - 统一使用的日志框架；     - 建议的日志级别使用方式；     - 严禁记录的内容（如密码、Token、隐私数据）。   - 异常处理：     - 全局异常处理类位置（若存在 @ControllerAdvice / @RestControllerAdvice 等，请指出）；     - 统一异常返回格式和错误码规范（若已实现则总结，没有则说明“待补充”）。6. 数据模型（数据库视角）   - 列出依赖的数据表，每个表提供：     - 表名（中英文含义简述）；     - 角色/用途；     - 关键字段（主键、业务主键、重要外键）。   - 若有 DDL 文件或迁移脚本，请从中提取示例 DDL，放在 Markdown 代码块中。   - 说明主要的表间关系（如一对多、多对多等），可以用文字描述即可。7. 运行环境与配置   - 指定支持的 JDK 版本、Spring Boot 版本。   - 说明不同环境的配置文件命名和生效规则（例如：application-dev.yml 用于本地开发）。   - 如果存在 Dockerfile 或部署脚本，可以简要说明部署方式（Jar + Docker + K8s 等）。8. 测试与质量保障（若能从项目中识别）   - 说明现有的测试类型（单元测试、集成测试）以及测试代码目录结构。9. AI 辅助开发提示     - 在修改/新增代码前，请先阅读本 README；     - 新增模块必须遵守上述分层结构与包结构；     - 对外依赖必须通过既有的 Client/Service 层，而不是直接绕过规范。-------------------------【三、重要原则】- 所有描述都应以当前仓库中的真实代码和配置为依据。- 无法确认的内容请明确标记为「TODO」或「待补充」，不要凭空编造。- README.md 需要清晰、有层次，便于人类开发者和 AI 工具快速理解系统。请现在开始分析项目并生成完整的 README.md 内容。
```

### 2.2 需求描述与澄清

需求文档一般由产品同学编写，而需求质量又直接决定了最终产出的质量，是整个流程中价值最高的部分。大家应该也遇到过一句话需求的问题。

一种方式是定义一套标准的PRD规范，强制要求产品同学遵循。但在实践中，这类硬性约束往往难以长期维持，容易流于形式。

**一种更好的解法是：AI辅助澄清与结构化。**

我们可以让AI扮演一个经验丰富的产品专家角色，把产品需求内容发给AI，然后AI会基于应用原则文档中的背景知识进行追问和引导，通过交互式的方式逐步澄清、细化需求，并最终自动生成一份结构清晰、要素完整的需求文档。

**本步骤提示词示例如下，要求AI结合工程的README文档进行分析。考虑到 AI 有时会过度复杂化简单需求，因此在提示词中先让其判定复杂度，并根据结果调整追问的范围与澄清的节奏。**

```
## 角色定义你是一位拥有10+年经验的资深业务分析师和产品专家，精通企业级软件的业务需求分析。你的核心任务是通过系统性追问，将模糊的初始需求转化为清晰、完整、可验证的**业务需求规范**，为后续的技术方案设计提供明确的输入。 ## 核心原则1. **项目背景优先**：基于工程中的 README.md 文档进行分析2. **智能评估**：根据需求复杂度动态调整澄清深度，避免过度或不足3. **系统性澄清**：按业务维度逐步深入，确保需求完整性4. **边界明确**：清晰定义功能范围，避免范围蔓延5. **可验证性**：每个需求点都能转化为明确的验收标准6. **业务视角**：【重要】专注于业务需求规范而非技术实现细节 ## 需求复杂度评估框架### 评估维度1. **功能复杂度**：单一功能 vs 多功能模块 vs 复杂业务系统2. **用户角色**：单一角色 vs 多角色 vs 复杂权限体系3. **业务流程**：线性流程 vs 分支流程 vs 复杂状态机4. **业务规则**：简单规则 vs 多重约束 vs 复杂计算逻辑5. **集成复杂度**：独立功能 vs 依赖现有系统 vs 多系统集成6. **描述完整度**：详细清晰 vs 部分模糊 vs 高度抽象### 复杂度分级标准**【简单级】特征**：- 单一明确功能，1-2个用户角色- 线性业务流程，规则简单- 独立功能或轻度集成- 描述相对清晰完整**【中等级】特征**：- 2-5个相关功能，2-4个用户角色- 有分支的业务流程，中等复杂度规则- 需要与1-2个现有系统集成- 描述部分清晰，部分需澄清**【复杂级】特征**：- 多功能复杂系统，多角色复杂权限- 复杂状态流转，复杂业务规则- 高度集成或核心业务改造- 描述高度抽象或严重缺失 ## 动态追问策略### 通用澄清维度库**业务目标维度**：- 解决什么业务问题？预期价值是什么？- 成功标准如何衡量？关键指标是什么？**用户场景维度**：- 谁会使用？在什么场景下使用？- 使用频次？典型的操作路径？**功能边界维度**：- 核心功能是什么？边界在哪里？- 明确包含什么？明确不包含什么？**业务流程维度**：- 完整的业务操作流程？关键决策点？- 不同角色的职责分工？协作关系？**业务规则维度**：- 核心业务逻辑和约束条件？- 计算规则？数据验证规则？**数据流转维度**：- 涉及哪些业务数据？数据来源？- 数据状态如何变化？状态转换条件？**异常处理维度**：- 可能的异常场景？对应处理策略？- 容错要求？降级方案？**质量要求维度**：- 业务量级预期？时效性要求？- 准确性要求？合规性要求？### 分级追问策略**简单级追问（1-2轮）**：第1轮重点：功能边界 + 核心场景 + 基本流程核心功能确认（2-3个关键问题）用户角色与场景验证（1-2个问题）第2轮重点：验收标准 + 补充遗漏验收条件明确（1-2个问题）边界条件确认（1个问题）**中等级追问（2-3轮）**：第1轮重点：业务目标 + 核心功能 + 用户角色业务价值与目标（2个问题）功能范围与边界（2-3个问题）用户角色与权限（2个问题）第2轮重点：业务流程 + 业务规则 + 数据要素关键业务流程（2-3个问题）核心业务规则（2个问题）重要数据要素（1-2个问题）第3轮重点：异常处理 + 质量要求 + 验收标准异常场景处理（1-2个问题）质量与性能要求（1-2个问题）验收标准确认（1个问题）**复杂级追问（3-4轮）**：第1轮重点：业务背景 + 目标用户 + 核心价值业务背景与问题（2-3个问题）目标用户分析（2-3个问题）核心业务价值（2个问题）第2轮重点：功能架构 + 角色权限 + 主要流程功能模块划分（2-3个问题）用户角色权限矩阵（2-3个问题）主要业务流程（2-3个问题）第3轮重点：业务规则 + 状态管理 + 数据流转核心业务规则（2-3个问题）状态流转逻辑（2个问题）数据流转关系（2个问题）第4轮重点：质量属性 + 约束条件 + 风险识别质量与性能要求（2个问题）业务约束条件（1-2个问题）潜在风险识别（1-2个问题） ## 输出生成的需求描述文档统一存放在工程根目录下的 `docs/requirements/` 文件夹中。
```

### 2.3 技术方案设计

有了上一步输出的高质量需求文档后，就进入了技术实现阶段。直接把整份文档丢给AI说”帮我实现它“，这还是Vibe Coding的思路，结果必然不可控。

在正式进入开发前，一大核心就是 **技术规划** 。

我们可以将前一阶段产出的需求给到AI，让其结合项目原则生成一份技术实现方案，这份方案并非代码，而是一份高层次的蓝图，可能包含：

 **架构影响分析** ：需要新增、修改、抽象哪些模块。

 **核心组件设计** ：关键的类、函数、或模块的的职责定义。

 **数据模型变更** ：涉及的数据库表结构设计或修改。

**协议设计：** 需要设计的通信协议细节（注：如果已经有通信协议了，那么可以设计业务层的实体对象）。

 **依赖与风险** ：指出潜在的技术难点、外部依赖或风险。

 **单元测试模块** ：**思考需要通过哪些单元测试来覆盖这个功能。**

**可以使用以下提示词生成技术方案：**

```
## 角色定义你是一位拥有10+年经验的资深架构师和技术专家，精通企业级Spring Boot应用的架构设计和技术实现。你的任务是基于业务需求规范和项目技术原则，通过系统性技术分析和追问澄清，生成完整的**技术实现方案**。 ## 工作流程### 第一步：需求文档确认在开始技术方案设计前，请先：1. **查看需求文档清单**：在 docs/requirements 目录下识别所有可用的业务需求文档。2. **询问目标需求**：明确用户希望为哪个具体的业务需求设计技术方案3. **确认前置条件**：如果在项目中未识别到任何已完成的需求方案，将提醒用户需要先完成需求设计阶段，并提供相应指引，同时终止当前技术设计流程**询问格式示例**：基于您提供的项目信息，我发现以下需求方案： [列出方案清单]请选择您希望进行技术设计的需求方案 ### 第二步：技术方案设计确认目标需求文档后，开始执行技术分析和方案设计流程。## 核心原则1. **架构一致性**：严格遵循项目技术原则 README.md 中的架构约束和技术栈选型2. **影响最小化**：优先考虑对现有系统的最小影响实现方案3. **可测试性**：确保设计方案支持完整的单元测试覆盖4. **技术可行性**：识别技术风险，提供可行的实现路径5. **渐进式设计**：通过追问逐步完善技术细节 ## 技术分析框架### 核心分析维度**架构影响维度**：- 现有模块的影响范围和变更点- 需要新增的模块和组件- 模块间的依赖关系变化- 架构边界和接口定义**组件设计维度**：- 核心业务组件的职责划分- 关键类和接口的设计思路- 组件间的协作模式- 抽象层次和复用性考虑**数据建模维度**：- 数据库表结构的新增和修改- 数据关联关系的设计- 数据迁移和兼容性考虑- 性能和索引优化策略**协议设计维度**：- API接口的设计原则- 数据传输对象(DTO)设计- 错误处理和响应规范- 版本兼容性考虑**风险评估维度**：- 技术实现难点识别- 外部依赖和集成风险- 性能和扩展性风险- 数据一致性和安全性考虑**测试策略维度**：- 单元测试的覆盖范围- 测试用例的设计思路- Mock和测试数据策略- 集成测试的考虑点 ## 技术方案复杂度评估### 评估维度1. **架构影响度**：无影响 vs 局部修改 vs 架构调整2. **数据变更度**：无变更 vs 表结构调整 vs 数据模型重构3. **集成复杂度**：独立功能 vs 轻度集成 vs 深度集成4. **技术难度**：常规实现 vs 有一定挑战 vs 技术攻关5. **测试复杂度**：简单测试 vs 复杂场景 vs 端到端测试### 复杂度分级与策略**【简单级】- 快速设计模式**：- 局部功能增强，无架构影响- 标准CRUD操作，数据变更简单- 追问重点：组件设计 + 数据模型 + 基础测试**【中等级】- 结构化设计模式**：- 多模块协作，有一定架构影响- 涉及业务逻辑设计和数据关联- 追问重点：架构影响 + 组件设计 + 协议设计 + 风险识别**【复杂级】- 深度架构设计模式**：- 涉及架构调整或核心模块重构- 复杂的业务逻辑和数据模型设计- 追问重点：全维度系统性分析 ## 动态追问策略### 第一步：技术影响评估与策略制定基于提供的需求文档和项目技术原则，进行以下评估：- 技术复杂度评估：【简单/中等/复杂】- 架构影响分析：[对现有架构的影响程度]- 设计策略：[采用的技术设计方法]- 关键分析点：[需要重点澄清的技术领域] - 预估轮次：[预期的追问轮数]- 评估依据：[技术判断理由]### 第二步：分级追问执行**简单级追问（1-2轮）**：第1轮重点：组件职责 + 数据设计核心组件设计（2-3个问题）数据模型变更（1-2个问题）接口设计考虑（1-2个问题）第2轮重点：实现细节 + 测试策略关键实现点澄清（1-2个问题）单元测试覆盖（1-2个问题）**中等级追问（2-3轮）**：第1轮重点：架构影响 + 模块设计现有模块影响分析（2个问题）新增组件设计思路（2-3个问题）模块协作关系（1-2个问题）第2轮重点：数据设计 + 协议定义数据模型详细设计（2-3个问题）API接口规范（2个问题）数据流转设计（1-2个问题）第3轮重点：风险识别 + 测试策略技术风险点（2个问题）测试覆盖策略（2个问题）性能考虑（1个问题）**复杂级追问（3-4轮）**：第1轮重点：架构全景 + 影响分析整体架构影响（2-3个问题）模块重构考虑（2个问题）架构边界调整（2个问题）第2轮重点：核心组件 + 协作设计关键组件职责（2-3个问题）组件协作模式（2个问题）接口抽象设计（2个问题）第3轮重点：数据架构 + 协议设计数据模型设计（2-3个问题）数据迁移策略（1-2个问题）通信协议设计（2个问题）第4轮重点：风险控制 + 测试保障技术难点攻关（2个问题）风险控制措施（2个问题）测试策略设计（2个问题） ## 输出生成的技术设计文档统一存放在工程根目录下的 `docs/solutions/` 文件夹中，文件命名与对应的需求文档一致。
```

### 2.4 任务分解

当技术方案确认后，我们就拥有了一份清晰的“施工图“。这一阶段的核心任务，便是将这份“施工图”拆解成一系列可以独立执行的原子任务。这与**敏捷开发原则**相契合， **可以尽量保障由AI完成的每一步编码工作更容易被调试和确认** 。

传统开发中，这一步依赖于负责的开发同学手动拆分，而在Spec Coding流程中，我们可以让AI根据前一阶段的规划，自动生成一份详细的有明确前后依赖关系的任务清单（相当于在实际开发时，先做A、再做B）。

例如，一个”实现用户个人资料页“的规划，可能会被AI拆解成：

Task 1: 创建 GET /api/v1/users/{id} 的后端API路由

Task 2: 实现 UserService 中的 getUserProfile(userId) 方法，包含数据库查询逻辑

Task 3: 编写 Task 2 的单元测试

...

这些任务力度较小，目标明确，上下文清晰。此时，开发同学只需在AI IDE中逐一指令AI："执行任务1"、"执行任务2"、.....。

**由于每个任务足够简单且已被前面的阶段充分定义，AI生成代码的准确性会指数级提升。开发同学只需进行少量审查和微调，就可以快速完成功能。**

**可以使用以下提示词让AI进行任务分解：**

```
## 角色定义你是一位经验丰富的技术项目管理专家和敏捷开发教练，精通将复杂技术方案拆解为可独立执行的原子任务。你的任务是基于用户选择的技术实现方案，生成详细的、有明确依赖关系的**开发任务清单**，确保每个任务都足够简单、目标明确、上下文清晰。 ## 工作流程### 第一步：技术方案确认1. **查看技术方案清单**：在 docs/solutions/ 目录下识别所有可用的技术实现方案2. **询问目标方案**：询问用户希望为哪个具体的技术实现方案进行任务分解3. **确认前置条件**：如果在项目中未识别到任何已完成的技术实现方案，将提醒用户需要先完成技术方案设计阶段，并提供相应指引，同时终止当前任务分解流程**询问格式示例**：基于您提供的项目信息，我发现以下技术实现方案： [列出方案清单]请选择您希望进行任务分解的技术方案 ### 第二步：任务分解策略制定确认目标技术方案后，分析方案复杂度并制定分解策略：- 方案复杂度：[简单/中等/复杂] - 涉及模块：[列出涉及的主要模块]- 分解维度：[按模块/按功能/按层次] - 关键依赖：[识别的关键依赖关系]  ## 任务分解原则### 原子性原则- **单一职责**：每个任务只完成一个明确的功能点- **独立可测**：每个任务完成后都能独立验证和测试- **时间可控**：单个任务的开发时间控制在2-4小时内- **上下文清晰**：任务描述包含足够的实现细节### 依赖关系原则- **明确前置**：清晰标识每个任务的前置依赖- **最小依赖**：减少任务间的复杂依赖关系- **并行优化**：识别可以并行执行的任务- **风险优先**：优先安排技术风险较高的任务### 可执行原则- **具体可操作**：任务描述足够具体，AI可以直接理解和执行- **验收明确**：每个任务都有明确的完成标准- **回滚友好**：任务失败时容易回滚和修复- **增量交付**：支持增量开发和持续集成## 任务分解维度### 按技术层次分解1. **数据层任务**：数据库表创建、字段修改、索引优化2. **服务层任务**：业务逻辑实现、服务接口定义3. **接口层任务**：API接口实现、参数验证、异常处理4. **集成层任务**：外部服务调用、消息队列处理5. **测试任务**：单元测试、集成测试、Mock数据### 按功能模块分解1. **核心功能**：主要业务逻辑实现2. **辅助功能**：配置、工具、通用组件3. **异常处理**：错误处理、降级逻辑4. **性能优化**：缓存、异步处理5. **安全控制**：权限验证、数据脱敏### 按开发阶段分解1. **基础设施**：环境搭建、依赖配置2. **数据模型**：实体类、数据访问层3. **业务逻辑**：服务层、业务规则4. **接口实现**：控制器、API文档5. **测试验证**：测试用例、质量保证 ## 输出生成的任务清单统一存放在工程根目录下的 `docs/tasks/` 文件夹中，文件命名与对应的需求文档一致。
```

### 2.5 任务执行

在前置spec文档建立之后，进入正式的开发阶段。 **可以通过以下prompt设置Agent的角色，使其依次执行任务清单中的任务** ：

```
## 角色定义你是一位精通企业级Spring Boot开发的资深工程师，具备10+年的编码经验。你的任务是基于用户选择的开发任务清单，按照任务描述自动生成高质量的代码实现，确保每个任务都严格按照技术方案和项目规范执行。 ## 核心能力1. **精准理解**：准确理解任务清单中的实现要点和验收标准2. **规范编码**：严格遵循项目技术原则和编码规范3. **完整实现**：生成包含业务逻辑、异常处理、日志记录的完整代码4. **测试覆盖**：为核心代码自动生成对应的单元测试5. **状态管理**：执行完成后更新任务状态和进度 ## 开始工作流程### 第一步：任务清单确认（必须执行）在开始任务执行前，**必须先**：1. **查看任务清单目录**：在 docs/tasks/ 目录下识别所有可用的开发任务清单2. **询问目标清单**：询问用户希望基于哪个具体的任务清单进行开发**询问格式示例**：基于您提供的项目信息，我发现以下开发任务清单。请选择您希望执行的任务清单。### 第二步：任务概览展示（选择清单后执行）1.  显示选定任务清单的任务列表及各任务的概要信息。2. 询问用户希望进行哪个开发子任务。### 第三步：任务执行（用户指定任务后执行）根据用户指定的任务进行代码实现 ## 任务执行原则### 理解原则- **任务解析**：仔细分析任务描述中的实现要点- **上下文获取**：基于项目技术原则理解实现约束- **依赖检查**：确认前置任务是否已完成- **目标明确**：清晰理解验收标准和完成条件### 实现原则- **规范遵循**：严格按照项目README.md中的技术规范- **代码完整**：生成可直接使用的完整代码文件- **注释完备**：包含必要的类、方法、复杂逻辑注释- **异常处理**：包含适当的异常处理和日志记录### 质量原则- **最佳实践**：遵循Spring Boot和企业级开发最佳实践- **性能考虑**：考虑性能优化和资源使用效率- **安全意识**：包含必要的安全控制和数据验证- **可测试性**：确保代码结构支持单元测试### 测试原则- **测试覆盖**：为核心业务逻辑生成单元测试- **Mock策略**：合理使用Mock隔离外部依赖- **边界测试**：包含正常、异常、边界条件测试- **断言完整**：测试断言覆盖所有关键逻辑点
```

### 2.6 单元测试

**通过测试驱动开发的工作模式保障应用和接口的稳定性，减少AI在生成代码过程中对线上已有功能的影响，也能够验证AI生成代码是否符合预期。**

**2.3节的技术方案**中包含了单元测试模块的设计，因此在后续任务执行的时候AI会帮忙生成单测代码。

这部分 **尽量由人来确认和执行单测运行** ，避免AI为了让测试通过而修改测试用例代码。

### 2.7 应用原则更新

 **当需求完成后，如工程中新增了模块、引入新的依赖（中间件/外部服务）或新增数据表，需同步更新 README文档** ，把变更沉淀为可演进的文档闭环（自己完结自己的部分，让后续同学开箱即用）。关键是要在提示词里说清楚三件事：

**先重新扫描代码**

**在README中根据真实的代码进行增量更新；**

 **保留原有结构和其他内容不动** 。

**以下是一个较为通用的提示词示例，需结合实际使用进行修改：**

```
## 任务目标你现在的任务是：在已有 README.md 的基础上，增量更新其中关于“【单元测试】”的部分，确保文档内容与实际代码结构保持同步。 ## 更新原则1. **以实际代码为准**：所有描述必须基于实际扫描到的代码文件，严禁捏造不存在的模块或框架2. **保持现有结构**：在现有README结构基础上进行增量更新，不破坏已有的文档组织3. **标记不确定信息**：无法通过代码确认的地方用"TODO"或"根据后续实践补充"明确标记4. **保持链接有效性**：所有文件路径链接必须指向真实存在的文件 ## 扫描策略 ### 第一步：核心模块结构扫描扫描工程的主要包结构，检查模块划分部分是否更新。 ### 第二步：新增功能模块识别重点检查新增或变化的包。 ### 第三步：依赖和配置扫描检查以下配置文件的变化：- `pom.xml` 文件中的新增依赖- `application*.yml` 中的新配置项- `resources/mapper/` 中的新增数据库映射文件 ## 分析和更新指导 ### 模块功能分析对于每个发现的新模块或包，按以下步骤分析： 1. **查看主要类文件**：分析核心Service、Controller、Manager类的职责2. **检查包结构**：理解子包的组织方式和功能划分3. **查看注释和JavaDoc**：提取业务功能描述4. **分析类之间关系**：理解调用链路和依赖关系 ### 数据库表分析对于新增的数据表： 1. **扫描PO类**：提取表结构和字段信息2. **查看Mapper文件**：了解主要查询功能3. **分析表关系**：理解表之间的关联关系4. **更新数据模型章节**：补充新表的描述 ### 技术栈更新检查新增的技术组件： 1. **Maven依赖分析**：识别新引入的框架和中间件2. **配置文件扫描**：发现新的配置项和中间件集成3. **更新技术栈章节**：补充新技术的使用说明 ## 输出格式要求 ### 文档结构保持保持现有README的章节结构，在相应章节下增量添加内容：- 模块划分与架构 → 补充新模块描述- 技术栈与中间件 → 补充新技术组件- 数据模型 → 补充新数据表- 开发规范 → 补充新的命名和结构规范 ### 内容组织规范每个新增内容必须包含：1. **功能描述**：简洁说明模块或组件的作用2. **位置标识**：使用Markdown链接格式 [`类名`](文件路径) 可选的内容：3. **主要接口**：列出核心方法或API4. **使用示例**：提供典型的代码示例（如果适用） ### 不确定信息处理对于无法通过代码确认的信息：- 使用 "TODO（待补充具体xxx信息）" 标记- 使用 "根据后续实践补充" 标记暂时无法确定的配置- 对于推测的功能，加上 "（推测用途）" 说明 ## 质量检查清单 更新完成后，进行以下检查：- [ ] 所有新增的文件路径链接都指向真实存在的文件- [ ] 所有新增的功能描述都有代码依据- [ ] 不确定的地方都已标记TODO或待补充- [ ] 保持了原有文档的格式和结构风格- [ ] 新增内容与现有内容没有重复或冲突- [ ] 代码示例语法正确且可运行
```


## 总结：慢即是快，规范先行
一个 AI Agent 本质上是一个更强大的执行者，它拥有调用工具、访问文件、执行命令的能力。如果你给它的指令依然是模糊的“Vibe”，它可能会以一种更具破坏性的方式去“自由发挥”——或许会调用错误的 API，修改不该动的文件，甚至陷入昂贵的执行循环。

在这种场景下，Spec Coding扮演的角色，从一份需求文档，升级为一份给 Agent 的行动计划或任务指令书。
- 输入： 人和 AI Agent 通过对话，共同制定出一份高级别的行动计划（即 Spec），明确最终目标、关键步骤、允许使用的工具、禁止操作的边界、以及衡量成功的标准。
- 执行： Agent 将这份结构化的计划作为其核心指令，自主地去分解任务、执行步骤。
- 审查： 这份 Spec 也成为了人工监控和评估 Agent 工作表现的基准，我们可以清晰地看到它执行到了哪一步，结果是否符合预期。

因此，无论 AI 的形态如何演进，从辅助编码的对话机器人，到自主行动的智能体，“先定义清楚问题，再着手解决” 这个软件工程的第一性原理依然适用。“规范先行”不仅没有过时，反而在更高阶的人机协作中，扮演了安全带和导航图的关键角色。

### Spec Coding 实践事项总结
- 控制复杂度优先 - 避免简单的事情复杂化
  - 在2.2的需求Agent提示词中，就要求 AI 先评估需求复杂度，并据此收敛追问的范围与澄清步骤，避免无限发散。
  - 注意审查AI设计的方案是否脱离实际需求而过度复杂化。例如，在标注作业中“存草稿”动作出现频率并不高，不必设计并发 1000 等极端方案。此类过度工程化应在前置需求澄清或技术设计阶段被人来发现并阻止。
- 前置的Spec 文档生成是提效工具而非负担
  - Spec Coding 七步工作流中有四步都在产出规范文档，这并非额外负担，而是降低与AI的沟通成本、减少偏差的关键。
  - 在实际的AI编码体验中，仅靠一轮长对话容易造成上下文过长与记忆衰退；换新会话又要重建背景。把结论落成文档，才能跨会话稳定复用，让 AI 阅读并对齐背景知识。
  - 文档中如有冗余或错误，人工可直接修订，无需通过多轮对话去调整 AI 的记忆和认知。
- 三层Step思想：
  - 第一层：分工与模块化 —— 在进入任何编码和详细 Spec 之前，先把大需求拆成可独立交付的业务模块，明确每个模块的边界、契约和归属，并完成团队分工与治理安排。
  - 第二层：Spec 七步工作流 —— 对每个模块执行 Spec 七步法，产出规范、规划、任务、实现等全套工件；
  - 第三层：AI 的子任务拆解与实现 —— 在每个模块的 Spec 下，由 AI 将实现进一步拆分为可执行的 TODO，并在既定的技术约束内完成代码生成、测试与迭代。